<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>3</storyId>
    <title>SQLite-Datenbank mit TypeORM integrieren</title>
    <status>drafted</status>
    <generatedAt>2025-11-06</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-3-sqlite-datenbank-mit-typeorm-integrieren.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Entwickler</asA>
    <iWant>eine funktionierende SQLite-Datenbank-Verbindung</iWant>
    <soThat>Entities persistiert werden können</soThat>
    <tasks>
      <task id="1" ac-ref="1">
        <title>TypeORM Dependencies installieren</title>
        <subtasks>
          <subtask>@nestjs/typeorm, typeorm, sqlite3 in apps/backend installieren</subtask>
          <subtask>Versionen: typeorm ^0.3.20, sqlite3 ^5.1.7 gemäß Tech Spec</subtask>
        </subtasks>
      </task>
      <task id="2" ac-ref="1,3">
        <title>Database Module konfigurieren</title>
        <subtasks>
          <subtask>DatabaseModule mit TypeOrmModule.forRoot() in AppModule importieren</subtask>
          <subtask>SQLite-Connection-Options konfigurieren (type: 'sqlite', database: path, synchronize: false)</subtask>
          <subtask>Environment-Variable DATABASE_PATH in .env definieren (default: 'data/cv-hub.db')</subtask>
          <subtask>Config-Validation für DATABASE_PATH erweitern (Zod-Schema)</subtask>
        </subtasks>
      </task>
      <task id="3" ac-ref="2">
        <title>Data-Directory und Persistence einrichten</title>
        <subtasks>
          <subtask>data/ Verzeichnis in Projekt-Root erstellen</subtask>
          <subtask>data/ zu .gitignore hinzufügen (DB-Datei nie committen)</subtask>
          <subtask>SQLite-Datei wird automatisch bei erster Connection erstellt</subtask>
          <subtask>Verifizieren: data/cv-hub.db existiert nach Server-Start</subtask>
        </subtasks>
      </task>
      <task id="4" ac-ref="5">
        <title>TypeORM-CLI Integration</title>
        <subtasks>
          <subtask>typeorm Script in apps/backend/package.json definieren</subtask>
          <subtask>DataSource-Konfiguration für CLI erstellen (apps/backend/src/database/data-source.ts)</subtask>
          <subtask>Migration-Verzeichnis konfigurieren (apps/backend/src/database/migrations)</subtask>
          <subtask>Test: pnpm typeorm migration:generate und pnpm typeorm migration:run funktionieren</subtask>
        </subtasks>
      </task>
      <task id="5" ac-ref="6">
        <title>Dummy-Entity erstellen</title>
        <subtasks>
          <subtask>SystemConfig Entity mit @Entity() Decorator erstellen</subtask>
          <subtask>Eigenschaften: id (PrimaryGeneratedColumn), key (string), value (string), updatedAt (timestamp)</subtask>
          <subtask>Entity in TypeORM-Config registrieren (entities: [SystemConfig])</subtask>
          <subtask>Migration für SystemConfig generieren und ausführen</subtask>
          <subtask>Verifizieren: systemconfig-Tabelle existiert in SQLite-DB</subtask>
        </subtasks>
      </task>
      <task id="6" ac-ref="4">
        <title>Health-Check um DB-Status erweitern</title>
        <subtasks>
          <subtask>HealthService erweitern mit checkDatabaseConnection() Methode</subtask>
          <subtask>TypeORM DataSource.isInitialized prüfen</subtask>
          <subtask>Health-Check-Response um database-Property erweitern: { status: 'connected' | 'disconnected', type: 'sqlite' }</subtask>
          <subtask>Test: GET /api/health zeigt "database": { "status": "connected", "type": "sqlite" }</subtask>
        </subtasks>
      </task>
      <task id="7" ac-ref="6">
        <title>Repository Pattern testen</title>
        <subtasks>
          <subtask>SystemConfigService mit InjectRepository(SystemConfig) erstellen</subtask>
          <subtask>CRUD-Methoden: create(), findByKey(), update(), delete()</subtask>
          <subtask>Seed-Daten: SystemConfig-Entry "app.version" = "0.1.0" erstellen</subtask>
          <subtask>Integration-Test: SystemConfig kann gespeichert und gelesen werden</subtask>
        </subtasks>
      </task>
      <task id="8">
        <title>Error Handling und Logging (NFR)</title>
        <subtasks>
          <subtask>Database-Connection-Errors loggen (Pino)</subtask>
          <subtask>Graceful Shutdown: Database-Connection schließen bei App-Shutdown</subtask>
          <subtask>TypeORM Logging aktivieren (development: true, production: errors only)</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">TypeORM in apps/backend konfiguriert mit SQLite-Driver</criterion>
    <criterion id="2">SQLite-Datenbank-Datei wird unter data/cv-hub.db erstellt und ist persistent</criterion>
    <criterion id="3">Database-Connection wird beim Server-Start etabliert und validiert</criterion>
    <criterion id="4">Health-Check-Endpoint zeigt DB-Status (connected / disconnected)</criterion>
    <criterion id="5">TypeORM-CLI-Befehle funktionieren (Migrations generieren/ausführen)</criterion>
    <criterion id="6">Dummy-Entity (z.B. SystemConfig) kann erstellt und gelesen werden</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Services and Modules → Backend - Database Module</section>
        <snippet>TypeORM-Konfiguration mit SQLite-Connection. Environment-Variable DATABASE_PATH in .env definiert (default: 'data/cv-hub.db'). TypeORM Connection wird beim Server-Start etabliert und validiert.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Dependencies → Database &amp; ORM</section>
        <snippet>@nestjs/typeorm ^11.0.0 - TypeORM integration für NestJS. typeorm ^0.3.20 - TypeScript ORM. sqlite3 ^5.1.7 - SQLite3 driver.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Data Models → Health Check Response</section>
        <snippet>HealthCheckResponse DTO erweitert um database property: { status: 'connected' | 'disconnected', type: 'sqlite' }. TypeORM DataSource.isInitialized prüfen für DB-Status.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Workflows → Database Initialization Sequence</section>
        <snippet>TypeORM prüft ob SQLite-File existiert. Falls nicht: File erstellen, alle Migrations ausführen. Falls existent: nur pending Migrations ausführen. synchronize: false in Production (Schema nur via Migrations).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>cv-hub Architecture Document</title>
        <section>Backend Stack → Database</section>
        <snippet>SQLite gewählt für Einfachheit: File-based, keine separate DB-Server-Installation, Perfect for &lt;50k users, Easy backups. TypeORM als ORM: NestJS-native Integration, Decorator-basierte Entity-Definition, Migration-Support.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>cv-hub Architecture Document</title>
        <section>Technical Stack Decisions → Why SQLite?</section>
        <snippet>Simple deployment (single file), Zero config, Sufficient for &lt;50k requests/month, Easy backups (cp command), Can migrate to PostgreSQL if scale requires.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>apps/backend/src/health/health.service.ts</path>
        <kind>service</kind>
        <symbol>HealthService.getHealthStatus()</symbol>
        <lines>12-27</lines>
        <reason>Existing health check service that needs to be extended with real TypeORM DataSource connection check. Currently returns placeholder "connected" status.</reason>
      </artifact>
      <artifact>
        <path>apps/backend/src/config/env.schema.ts</path>
        <kind>config</kind>
        <symbol>envSchema, validateEnv()</symbol>
        <lines>1-23</lines>
        <reason>Zod schema for environment validation. DATABASE_PATH already defined (line 6) with default './data/cv-hub.db'. Pattern to follow for validation.</reason>
      </artifact>
      <artifact>
        <path>apps/backend/.env.example</path>
        <kind>config</kind>
        <symbol>DATABASE_PATH</symbol>
        <lines>11</lines>
        <reason>Environment variable template already includes DATABASE_PATH=./data/cv-hub.db. No changes needed.</reason>
      </artifact>
      <artifact>
        <path>apps/backend/package.json</path>
        <kind>manifest</kind>
        <symbol>dependencies</symbol>
        <lines>27-39</lines>
        <reason>Current dependencies baseline. TypeORM and sqlite3 need to be added. NestJS 11 already installed. ConfigService pattern already in use.</reason>
      </artifact>
      <artifact>
        <path>apps/backend/src/health/health.module.ts</path>
        <kind>module</kind>
        <symbol>HealthModule</symbol>
        <lines>-</lines>
        <reason>Existing NestJS module for health check. Will need to import TypeOrmModule.forFeature if SystemConfig repository needed.</reason>
      </artifact>
    </code>
    <dependencies>
      <node>
        <package name="@nestjs/typeorm" version="^11.0.0">TypeORM integration for NestJS</package>
        <package name="typeorm" version="^0.3.20">TypeScript ORM with decorator-based entities</package>
        <package name="sqlite3" version="^5.1.7">SQLite3 database driver</package>
        <package name="@nestjs/common" version="^11.0.0">Already installed</package>
        <package name="@nestjs/core" version="^11.0.0">Already installed</package>
        <package name="@nestjs/config" version="^3.3.0">Already installed</package>
        <package name="zod" version="^3.24.1">Already installed</package>
        <package name="pino-pretty" version="^13.0.0">Already installed for logging</package>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>synchronize: false in production - Schema changes ONLY via TypeORM migrations, never auto-sync</constraint>
    <constraint>synchronize: true allowed only in test environment for faster test execution</constraint>
    <constraint>Database path: data/cv-hub.db (relative to project root), data/ directory in .gitignore</constraint>
    <constraint>Environment validation: DATABASE_PATH must pass Zod schema validation before server starts</constraint>
    <constraint>Health check must show real DB status via TypeORM DataSource.isInitialized (not placeholder)</constraint>
    <constraint>Migration strategy: Migrations committed to Git, reproducible schema evolution</constraint>
    <constraint>NestJS Module pattern: DatabaseModule separate from AppModule, imported via TypeOrmModule.forRoot()</constraint>
    <constraint>TypeORM logging: enabled in development (structured JSON), errors-only in production</constraint>
    <constraint>Graceful shutdown: Database connection must close cleanly on app shutdown (NestJS lifecycle hooks)</constraint>
    <constraint>TypeScript strict mode: all entities and configs must have full type safety</constraint>
    <constraint>Config pattern: Use ConfigService.get() with type inference for all environment variables</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>HealthCheck (from @cv-hub/shared-types)</name>
      <kind>TypeScript interface</kind>
      <signature>
        interface HealthCheck {
          status: 'ok' | 'error';
          timestamp: string;
          uptime: number;
          database: {
            status: 'connected' | 'disconnected';
            type: 'sqlite';
          };
        }
      </signature>
      <path>packages/shared-types (workspace dependency)</path>
    </interface>
    <interface>
      <name>EnvConfig</name>
      <kind>Zod inferred type</kind>
      <signature>
        type EnvConfig = {
          NODE_ENV: 'development' | 'production' | 'test';
          PORT: number;
          DATABASE_PATH: string;
          CORS_ORIGIN: string;
          LOG_LEVEL: 'debug' | 'info' | 'warn' | 'error';
        }
      </signature>
      <path>apps/backend/src/config/env.schema.ts</path>
    </interface>
    <interface>
      <name>TypeORM DataSource API</name>
      <kind>External library API</kind>
      <signature>
        class DataSource {
          readonly isInitialized: boolean;
          initialize(): Promise&lt;DataSource&gt;;
          destroy(): Promise&lt;void&gt;;
          // Used for DB health check
        }
      </signature>
      <path>External: typeorm package</path>
    </interface>
    <interface>
      <name>TypeOrmModuleOptions</name>
      <kind>NestJS TypeORM config</kind>
      <signature>
        interface TypeOrmModuleOptions {
          type: 'sqlite';
          database: string;
          entities: any[];
          migrations: string[];
          synchronize: boolean;
          logging: boolean | 'all' | LoggerOptions;
        }
      </signature>
      <path>apps/backend/src/database/database.module.ts (to be created)</path>
    </interface>
  </interfaces>
  <tests>
    <standards>
      Testing framework: Jest for Backend (already configured via @nestjs/testing).
      Integration tests use Supertest for HTTP assertions (apps/backend/test/*.e2e-spec.ts).
      Unit tests mock dependencies (TypeORM repositories mocked with jest.mock).
      Test database: In-memory SQLite (:memory:) for isolated test execution.
      Coverage target: 80% for Database Module, 90% for Health Check integration.
      Test naming: AAA pattern (Arrange-Act-Assert), descriptive test names.
    </standards>
    <locations>
      Unit tests: apps/backend/src/**/*.spec.ts
      Integration/E2E tests: apps/backend/test/**/*.e2e-spec.ts
      Test config: apps/backend/test/jest-e2e.json
    </locations>
    <ideas>
      <test ac-ref="1" type="unit">TypeORM module loads successfully with valid config</test>
      <test ac-ref="1" type="unit">DatabaseModule throws error if DATABASE_PATH is invalid</test>
      <test ac-ref="2" type="integration">SQLite file created at data/cv-hub.db after server start</test>
      <test ac-ref="2" type="integration">Database file persists after server restart</test>
      <test ac-ref="3" type="integration">TypeORM connection established on app bootstrap</test>
      <test ac-ref="3" type="unit">Health service calls DataSource.isInitialized correctly</test>
      <test ac-ref="4" type="integration">GET /api/health returns database.status='connected' when DB is up</test>
      <test ac-ref="4" type="integration">GET /api/health returns database.status='disconnected' when DB is down</test>
      <test ac-ref="5" type="manual">pnpm typeorm migration:generate creates migration file</test>
      <test ac-ref="5" type="manual">pnpm typeorm migration:run applies migration successfully</test>
      <test ac-ref="6" type="integration">SystemConfig entity can be saved to database</test>
      <test ac-ref="6" type="integration">SystemConfig entity can be retrieved by key</test>
      <test ac-ref="6" type="unit">SystemConfigService CRUD methods work with mocked repository</test>
    </ideas>
  </tests>
</story-context>
