<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>8</storyId>
    <title>CI/CD-Pipeline Unit-Tests</title>
    <status>drafted</status>
    <generatedAt>2025-11-08</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-8-ci-cd-pipeline-unit-tests.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Entwickler</asA>
    <iWant>automatische Unit-Tests in der CI-Pipeline</iWant>
    <soThat>Regressionen früh erkannt werden</soThat>
    <tasks>
      <task id="1" ac="#1">
        <title>Vitest für Frontend konfigurieren</title>
        <subtasks>
          <subtask id="1.1">Installiere Vitest-Dependencies: vitest, @vitest/ui, @testing-library/react, @testing-library/jest-dom, @vitejs/plugin-react</subtask>
          <subtask id="1.2">Erstelle apps/frontend/vitest.config.ts mit Vite-Plugin und Test-Environment (jsdom)</subtask>
          <subtask id="1.3">Füge Test-Scripts zu apps/frontend/package.json hinzu: test, test:watch, test:coverage</subtask>
          <subtask id="1.4">Erstelle Test-Setup-File: apps/frontend/test/setup.ts (importiere @testing-library/jest-dom)</subtask>
        </subtasks>
      </task>
      <task id="2" ac="#2">
        <title>Jest für Backend konfigurieren</title>
        <subtasks>
          <subtask id="2.1">Installiere Jest-Dependencies (sollten bereits vorhanden sein via @nestjs/testing)</subtask>
          <subtask id="2.2">Überprüfe/erstelle apps/backend/jest.config.js (NestJS preset)</subtask>
          <subtask id="2.3">Installiere Supertest für HTTP-Tests: pnpm add -D supertest @types/supertest</subtask>
          <subtask id="2.4">Füge Test-Scripts zu apps/backend/package.json hinzu: test, test:watch, test:cov</subtask>
        </subtasks>
      </task>
      <task id="3" ac="#3">
        <title>Backend Health-Check Test schreiben</title>
        <subtasks>
          <subtask id="3.1">Erstelle apps/backend/test/health.e2e-spec.ts</subtask>
          <subtask id="3.2">Schreibe Integration-Test: GET /api/health → Status 200, Body-Schema-Validation</subtask>
          <subtask id="3.3">Führe Test lokal aus: cd apps/backend &amp;&amp; pnpm test</subtask>
          <subtask id="3.4">Verifiziere: Test passed</subtask>
        </subtasks>
      </task>
      <task id="4" ac="#3">
        <title>Frontend Smoke-Test schreiben</title>
        <subtasks>
          <subtask id="4.1">Erstelle apps/frontend/test/App.test.tsx (oder Root-Component-Test)</subtask>
          <subtask id="4.2">Schreibe Smoke-Test: Root-Component rendert ohne Errors, erwarteter Text vorhanden</subtask>
          <subtask id="4.3">Führe Test lokal aus: cd apps/frontend &amp;&amp; pnpm test</subtask>
          <subtask id="4.4">Verifiziere: Test passed</subtask>
        </subtasks>
      </task>
      <task id="5" ac="#4,#6">
        <title>GitHub Actions Workflow um Test-Jobs erweitern</title>
        <subtasks>
          <subtask id="5.1">Öffne .github/workflows/ci.yml</subtask>
          <subtask id="5.2">Füge neuen Job test hinzu (parallel zu lint, type-check)</subtask>
          <subtask id="5.3">Job-Steps: Setup Node.js 20 LTS, Install Dependencies: pnpm install, Run Backend Tests: cd apps/backend &amp;&amp; pnpm test, Run Frontend Tests: cd apps/frontend &amp;&amp; pnpm test</subtask>
          <subtask id="5.4">Committe Workflow-Änderung und pushe zu GitHub</subtask>
          <subtask id="5.5">Verifiziere: GitHub Actions läuft, Test-Job ist grün</subtask>
        </subtasks>
      </task>
      <task id="6" ac="#5">
        <title>Coverage-Report konfigurieren</title>
        <subtasks>
          <subtask id="6.1">Backend: Füge test:cov Script hinzu (Jest Coverage)</subtask>
          <subtask id="6.2">Frontend: Füge test:coverage Script hinzu (Vitest Coverage)</subtask>
          <subtask id="6.3">Optional: Generiere Coverage-Report als Artifact in GitHub Actions</subtask>
          <subtask id="6.4">Optional: Füge Coverage-Badge zu README hinzu</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">
      <title>Vitest für Frontend konfiguriert (in apps/frontend)</title>
      <requirements>
        <requirement>Vitest v2.1.8+ installiert</requirement>
        <requirement>Test-Setup mit @testing-library/react und @testing-library/jest-dom</requirement>
        <requirement>Vitest-Config in apps/frontend/vitest.config.ts</requirement>
        <requirement>Test-Script in apps/frontend/package.json: "test": "vitest run"</requirement>
      </requirements>
    </criterion>
    <criterion id="2">
      <title>Jest für Backend konfiguriert (in apps/backend)</title>
      <requirements>
        <requirement>Jest v29.7.0+ installiert</requirement>
        <requirement>Jest-Config in apps/backend/jest.config.js</requirement>
        <requirement>Supertest für HTTP-Assertions installiert</requirement>
        <requirement>Test-Script in apps/backend/package.json: "test": "jest"</requirement>
      </requirements>
    </criterion>
    <criterion id="3">
      <title>Mindestens 1 Dummy-Test pro App</title>
      <requirements>
        <requirement>Backend: Health-Check Integration-Test (GET /api/health liefert 200)</requirement>
        <requirement>Frontend: Smoke-Test (z.B. Root-Component rendert ohne Fehler)</requirement>
        <requirement>Beide Tests laufen erfolgreich lokal</requirement>
      </requirements>
    </criterion>
    <criterion id="4">
      <title>GitHub Actions Workflow führt Tests aus</title>
      <requirements>
        <requirement>.github/workflows/ci.yml erweitert um Test-Job</requirement>
        <requirement>Tests laufen parallel zu Linting/Type-Checking</requirement>
        <requirement>Backend-Tests: cd apps/backend &amp;&amp; pnpm test</requirement>
        <requirement>Frontend-Tests: cd apps/frontend &amp;&amp; pnpm test</requirement>
        <requirement>Job schlägt fehl wenn Tests fehlschlagen (Exit Code != 0)</requirement>
      </requirements>
    </criterion>
    <criterion id="5">
      <title>Test-Coverage-Report wird generiert</title>
      <requirements>
        <requirement>Coverage-Report wird generiert (Terminal-Output)</requirement>
        <requirement>Optional: Coverage-Report als Artifact hochladen</requirement>
        <requirement>Optional: Coverage-Badge für README</requirement>
      </requirements>
    </criterion>
    <criterion id="6">
      <title>Workflow schlägt fehl bei fehlgeschlagenen Tests</title>
      <requirements>
        <requirement>PR kann nicht gemerged werden wenn Tests fehlschlagen</requirement>
        <requirement>Status-Check blockiert Merge</requirement>
        <requirement>Klare Fehlermeldung in GitHub Actions Log</requirement>
      </requirements>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Test Strategy Summary (Lines 1089-1276)</section>
        <snippet>Test Pyramid for Epic 1 mit definierten Levels: Unit Tests (70%+ Coverage für kritische Logic), Integration Tests (90%+ für API-Endpoints mit Jest+Supertest), Build Verification (100%), CI/CD Tests (ESLint, Prettier, pnpm audit). Test Execution Strategy definiert mit lokaler Development (watch mode), CI/CD (parallel jobs), Pre-Commit (Husky+lint-staged). Coverage Goals: Backend 80-100%, Frontend 50% (Placeholder only), Overall 70%.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Dependencies and Integrations - Testing (Lines 541-551, 584-593)</section>
        <snippet>Backend Testing: Jest v29.7.0 (Testing framework), Supertest v7.0.0 (HTTP assertions), @nestjs/testing v11.0.0 (NestJS testing utilities). Frontend Testing: Vitest v2.1.8 (Vite-native testing), @testing-library/react v16.1.0 (React testing utilities), @testing-library/jest-dom v6.6.3 (Custom matchers), @vitejs/plugin-react v4.3.4 (React plugin for Vitest).</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Workflows and Sequencing - CI/CD Pipeline Sequence (Lines 298-330)</section>
        <snippet>Developer pushes code to GitHub → GitHub Actions Trigger (.github/workflows/ci.yml) → Checkout Code → Setup Node.js 20 LTS → Install Dependencies (pnpm install) → Parallel Jobs: Linting (ESLint Backend+Frontend, Prettier Check), Type Checking (TypeScript Backend+Frontend), Testing (Jest Backend Unit Tests, Vitest Frontend Unit Tests) → Build Validation (Build Backend NestJS, Build Frontend TanStack Start).</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Testing Best Practices - AAA Pattern &amp; Test Isolation (Lines 1214-1252)</section>
        <snippet>Arrange-Act-Assert Pattern für alle Tests. Test Isolation: Jeder Test unabhängig (keine shared state), Database reset vor jedem Test (In-Memory SQLite für Tests), Mocks für externe Dependencies. Test Naming Convention: describe('HealthController') → describe('GET /api/health') → it('should return 200 when database is connected'). Fixtures &amp; Factories in test/fixtures/ für wiederverwendbare Mock-Daten.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Project Foundation &amp; Infrastructure</title>
        <section>Non-Functional Requirements - Performance (Lines 387-410)</section>
        <snippet>Test Suite Execution: &lt;30 Sekunden (alle Unit Tests). CI/CD Pipeline (Total): &lt;5 Minuten. Performance-Metriken für Epic 1 fokussieren auf Developer Experience. CI/CD-Pipeline tracked Build-Zeiten automatisch.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture Document</title>
        <section>Frontend Tech Stack - Testing (Line 138)</section>
        <snippet>Testing: Vitest + React Testing Library (RTL). Rationale: 3-4x faster than Jest, Vite-native integration.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture Document</title>
        <section>Deployment &amp; Infrastructure - CI/CD (Line 205)</section>
        <snippet>CI/CD: GitHub Actions. Automated testing, Build, Deploy on push.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>.github/workflows/ci.yml</path>
        <kind>github-actions-workflow</kind>
        <symbol>quality-checks job</symbol>
        <lines>1-38</lines>
        <reason>Existing CI pipeline that needs to be extended with test jobs. Currently has linting and type-checking, missing test execution.</reason>
      </artifact>
      <artifact>
        <path>apps/frontend/vitest.config.ts</path>
        <kind>config</kind>
        <symbol>vitest config</symbol>
        <lines>1-11</lines>
        <reason>Vitest configuration already exists with jsdom environment and setup file reference. Ready to use, just needs test files.</reason>
      </artifact>
      <artifact>
        <path>apps/backend/package.json</path>
        <kind>config</kind>
        <symbol>jest inline config</symbol>
        <lines>77-93</lines>
        <reason>Jest configuration inline in package.json with ts-jest transform, test regex, and coverage settings. No separate jest.config.js file exists.</reason>
      </artifact>
      <artifact>
        <path>apps/frontend/package.json</path>
        <kind>config</kind>
        <symbol>test scripts</symbol>
        <lines>12-13</lines>
        <reason>Frontend test scripts already defined: "test": "vitest", "test:ui": "vitest --ui". Ready to use.</reason>
      </artifact>
      <artifact>
        <path>apps/backend/package.json</path>
        <kind>config</kind>
        <symbol>test scripts</symbol>
        <lines>19-23</lines>
        <reason>Backend test scripts already defined: test, test:watch, test:cov, test:debug, test:e2e. Ready to use.</reason>
      </artifact>
      <artifact>
        <path>package.json</path>
        <kind>config</kind>
        <symbol>root test script</symbol>
        <lines>10</lines>
        <reason>Root-level test script aggregates all workspace tests: "test": "pnpm -r test". Will run both backend and frontend tests.</reason>
      </artifact>
    </code>
    <dependencies>
      <backend>
        <package name="jest" version="^29.7.0" dev="true">Testing framework for Backend</package>
        <package name="ts-jest" version="^29.2.5" dev="true">TypeScript preprocessor for Jest</package>
        <package name="@nestjs/testing" version="^11.0.0" dev="true">NestJS testing utilities</package>
        <package name="supertest" version="^7.0.0" dev="true">HTTP assertions for E2E tests</package>
        <package name="@types/supertest" version="^6.0.2" dev="true">TypeScript types for supertest</package>
        <package name="@types/jest" version="^29.5.13" dev="true">TypeScript types for Jest</package>
      </backend>
      <frontend>
        <package name="vitest" version="^4.0.8" dev="true">Vite-native testing framework</package>
        <package name="@vitest/ui" version="^4.0.8" dev="true">UI for Vitest</package>
        <package name="@testing-library/react" version="^16.1.0" dev="true">React testing utilities</package>
        <package name="@testing-library/jest-dom" version="^6.6.3" dev="true">Custom matchers for DOM</package>
        <package name="@vitejs/plugin-react" version="^4.6.0" dev="true">React plugin for Vitest</package>
        <package name="jsdom" version="^26.0.0" dev="true">Browser environment simulation</package>
        <package name="vite-tsconfig-paths" version="^5.1.4" dev="true">Path resolution for Vitest</package>
      </frontend>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint category="test-file-locations">
      <rule>Backend Unit Tests: apps/backend/src/**/*.spec.ts (co-located with source)</rule>
      <rule>Backend Integration Tests: apps/backend/test/**/*.e2e-spec.ts</rule>
      <rule>Frontend Tests: apps/frontend/test/**/*.test.tsx or src/**/*.test.tsx (flexible)</rule>
      <rule>Coverage Reports: apps/backend/coverage/ and apps/frontend/coverage/ (gitignored)</rule>
    </constraint>
    <constraint category="test-naming">
      <rule>Use AAA Pattern (Arrange-Act-Assert) for all tests</rule>
      <rule>Naming Convention: describe('ComponentName') → describe('method/endpoint') → it('should behavior')</rule>
      <rule>Backend E2E files must end with .e2e-spec.ts</rule>
      <rule>Frontend test files must end with .test.tsx or .test.ts</rule>
    </constraint>
    <constraint category="test-isolation">
      <rule>Each test must be independent (no shared state)</rule>
      <rule>Use In-Memory SQLite for Backend tests (faster than file-based)</rule>
      <rule>Frontend tests use jsdom environment (browser simulation)</rule>
      <rule>Mock external dependencies (no real API calls in tests)</rule>
    </constraint>
    <constraint category="ci-cd-requirements">
      <rule>Tests must run in parallel to linting/type-checking in CI</rule>
      <rule>Test job must fail if any test fails (exit code != 0)</rule>
      <rule>Total CI/CD pipeline must complete in &lt;5 minutes</rule>
      <rule>Test execution target: &lt;30 seconds for unit tests</rule>
    </constraint>
    <constraint category="coverage-targets">
      <rule>Backend: 80-100% coverage for critical modules (Health, Config)</rule>
      <rule>Frontend: 50% coverage minimum (Epic 1 has only placeholders)</rule>
      <rule>Overall project: 70% coverage target</rule>
      <rule>Coverage reports generated via test:cov (Backend) and test:coverage (Frontend)</rule>
    </constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>Backend Test Scripts</name>
      <kind>npm-scripts</kind>
      <signature>pnpm test - Run all Jest tests
pnpm test:watch - Run Jest in watch mode
pnpm test:cov - Generate coverage report
pnpm test:e2e - Run integration tests only</signature>
      <path>apps/backend/package.json</path>
    </interface>
    <interface>
      <name>Frontend Test Scripts</name>
      <kind>npm-scripts</kind>
      <signature>pnpm test - Run Vitest tests (default: watch mode in dev)
pnpm test:ui - Launch Vitest UI</signature>
      <path>apps/frontend/package.json</path>
    </interface>
    <interface>
      <name>Root Test Script</name>
      <kind>npm-scripts</kind>
      <signature>pnpm test - Run tests for all workspaces (Backend + Frontend + Shared-Types)</signature>
      <path>package.json</path>
    </interface>
    <interface>
      <name>GitHub Actions Workflow Extension Point</name>
      <kind>ci-cd-job</kind>
      <signature>Add new job "test" to .github/workflows/ci.yml
Parallel to existing "quality-checks" job
Steps: checkout → setup-node → install → run tests (backend + frontend)</signature>
      <path>.github/workflows/ci.yml</path>
    </interface>
    <interface>
      <name>Backend Health Endpoint (Test Target)</name>
      <kind>rest-endpoint</kind>
      <signature>GET /api/health → 200 OK
Response: { status: "ok", timestamp: string, uptime: number, database: { status: "connected", type: "sqlite" } }</signature>
      <path>apps/backend/src/health/health.controller.ts</path>
    </interface>
  </interfaces>
  <tests>
    <standards>
Testing frameworks are fully configured: Backend uses Jest v29.7.0 with ts-jest transformer and @nestjs/testing utilities. Frontend uses Vitest v4.0.8 with @testing-library/react and jsdom environment. All tests follow AAA Pattern (Arrange-Act-Assert). Backend integration tests use Supertest for HTTP assertions. Test isolation is enforced: no shared state, In-Memory SQLite for Backend tests, mocked external dependencies. Coverage targets: Backend 80-100% for critical modules, Frontend 50% minimum, Overall 70%. Tests run in CI/CD parallel to linting/type-checking with target execution time &lt;30 seconds for unit tests.
    </standards>
    <locations>
      <location>apps/backend/src/**/*.spec.ts - Backend unit tests (co-located)</location>
      <location>apps/backend/test/**/*.e2e-spec.ts - Backend integration tests</location>
      <location>apps/frontend/test/**/*.test.tsx - Frontend tests</location>
      <location>apps/frontend/src/**/*.test.tsx - Frontend tests (co-located alternative)</location>
      <location>apps/backend/coverage/ - Backend coverage reports (gitignored)</location>
      <location>apps/frontend/coverage/ - Frontend coverage reports (gitignored)</location>
    </locations>
    <ideas>
      <idea ac="3" priority="high">
        <test>Backend Health Check Integration Test (apps/backend/test/health.e2e-spec.ts)</test>
        <description>Test GET /api/health endpoint returns 200 with correct JSON structure. Verify database connection status, uptime field is number, timestamp is valid ISO string. Use Supertest for HTTP assertions.</description>
      </idea>
      <idea ac="3" priority="high">
        <test>Frontend Smoke Test (apps/frontend/test/App.test.tsx)</test>
        <description>Test that root component renders without errors. Verify placeholder text is visible. No console errors during render. Use @testing-library/react render and screen queries.</description>
      </idea>
      <idea ac="1,2" priority="medium">
        <test>Verify Test Configuration (manual verification)</test>
        <description>Run pnpm test locally in both apps/backend and apps/frontend to verify Vitest and Jest configurations work. Check that test:watch and test:cov scripts execute without errors.</description>
      </idea>
      <idea ac="4" priority="high">
        <test>CI Workflow Test Job (GitHub Actions)</test>
        <description>Extend .github/workflows/ci.yml with new "test" job. Parallel execution to quality-checks. Steps: checkout, setup-node, install deps, run backend tests (pnpm --filter @cv-hub/backend test), run frontend tests (pnpm --filter @cv-hub/frontend test). Job fails if any test fails.</description>
      </idea>
      <idea ac="5" priority="low">
        <test>Coverage Report Generation (manual verification)</test>
        <description>Run pnpm test:cov in backend and verify coverage/ directory is created with HTML report. Check that coverage metrics are displayed in terminal output. Optionally upload coverage as GitHub Actions artifact.</description>
      </idea>
      <idea ac="6" priority="medium">
        <test>Workflow Failure Behavior (integration test)</test>
        <description>Intentionally create failing test, push to GitHub, verify workflow fails and blocks PR merge. Check that GitHub Actions log shows clear error message indicating which test failed.</description>
      </idea>
    </ideas>
  </tests>
</story-context>
